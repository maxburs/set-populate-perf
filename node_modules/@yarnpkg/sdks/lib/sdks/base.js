"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BASE_SDKS = exports.generateFlowBinBaseWrapper = exports.generateSvelteLanguageServerBaseWrapper = exports.generateStylelintBaseWrapper = exports.generateTypescriptBaseWrapper = exports.generateTypescriptLanguageServerBaseWrapper = exports.generatePrettierBaseWrapper = exports.generateEslintBaseWrapper = void 0;
const generateSdk_1 = require("../generateSdk");
const generateEslintBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`eslint`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/eslint.js`);
    await wrapper.writeFile(`lib/api.js`, { requirePath: `` });
    return wrapper;
};
exports.generateEslintBaseWrapper = generateEslintBaseWrapper;
const generatePrettierBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`prettier`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`index.js`);
    return wrapper;
};
exports.generatePrettierBaseWrapper = generatePrettierBaseWrapper;
const generateTypescriptLanguageServerBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`typescript-language-server`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`lib/cli.js`);
    return wrapper;
};
exports.generateTypescriptLanguageServerBaseWrapper = generateTypescriptLanguageServerBaseWrapper;
const generateTypescriptBaseWrapper = async (pnpApi, target) => {
    const tsServerMonkeyPatch = `
    tsserver => {
      if (!process.versions.pnp) {
        return tsserver;
      }

      const {isAbsolute} = require(\`path\`);
      const pnpApi = require(\`pnpapi\`);

      const isVirtual = str => str.match(/\\/(\\$\\$virtual|__virtual__)\\//);
      const normalize = str => str.replace(/\\\\/g, \`/\`).replace(/^\\/?/, \`/\`);

      const dependencyTreeRoots = new Set(pnpApi.getDependencyTreeRoots().map(locator => {
        return \`\${locator.name}@\${locator.reference}\`;
      }));

      // VSCode sends the zip paths to TS using the "zip://" prefix, that TS
      // doesn't understand. This layer makes sure to remove the protocol
      // before forwarding it to TS, and to add it back on all returned paths.

      function toEditorPath(str) {
        // We add the \`zip:\` prefix to both \`.zip/\` paths and virtual paths
        if (isAbsolute(str) && !str.match(/^\\^?(zip:|\\/zip\\/)/) && (str.match(/\\.zip\\//) || isVirtual(str))) {
          // We also take the opportunity to turn virtual paths into physical ones;
          // this makes it much easier to work with workspaces that list peer
          // dependencies, since otherwise Ctrl+Click would bring us to the virtual
          // file instances instead of the real ones.
          //
          // We only do this to modules owned by the the dependency tree roots.
          // This avoids breaking the resolution when jumping inside a vendor
          // with peer dep (otherwise jumping into react-dom would show resolution
          // errors on react).
          //
          const resolved = isVirtual(str) ? pnpApi.resolveVirtual(str) : str;
          if (resolved) {
            const locator = pnpApi.findPackageLocator(resolved);
            if (locator && dependencyTreeRoots.has(\`\${locator.name}@\${locator.reference}\`)) {
              str = resolved;
            }
          }

          str = normalize(str);

          if (str.match(/\\.zip\\//)) {
            switch (hostInfo) {
              // Absolute VSCode \`Uri.fsPath\`s need to start with a slash.
              // VSCode only adds it automatically for supported schemes,
              // so we have to do it manually for the \`zip\` scheme.
              // The path needs to start with a caret otherwise VSCode doesn't handle the protocol
              //
              // Ref: https://github.com/microsoft/vscode/issues/105014#issuecomment-686760910
              //
              // Update Oct 8 2021: VSCode changed their format in 1.61.
              // Before | ^zip:/c:/foo/bar.zip/package.json
              // After  | ^/zip//c:/foo/bar.zip/package.json
              //
              case \`vscode <1.61\`: {
                str = \`^zip:\${str}\`;
              } break;

              case \`vscode\`: {
                str = \`^/zip/\${str}\`;
              } break;

              // To make "go to definition" work,
              // We have to resolve the actual file system path from virtual path
              // and convert scheme to supported by [vim-rzip](https://github.com/lbrayner/vim-rzip)
              case \`coc-nvim\`: {
                str = normalize(resolved).replace(/\\.zip\\//, \`.zip::\`);
                str = resolve(\`zipfile:\${str}\`);
              } break;

              // Support neovim native LSP and [typescript-language-server](https://github.com/theia-ide/typescript-language-server)
              // We have to resolve the actual file system path from virtual path,
              // everything else is up to neovim
              case \`neovim\`: {
                str = normalize(resolved).replace(/\\.zip\\//, \`.zip::\`);
                str = \`zipfile:\${str}\`;
              } break;

              default: {
                str = \`zip:\${str}\`;
              } break;
            }
          }
        }

        return str;
      }

      function fromEditorPath(str) {
        switch (hostInfo) {
          case \`coc-nvim\`:
          case \`neovim\`: {
            str = str.replace(/\\.zip::/, \`.zip/\`);
            // The path for coc-nvim is in format of /<pwd>/zipfile:/<pwd>/.yarn/...
            // So in order to convert it back, we use .* to match all the thing
            // before \`zipfile:\`
            return process.platform === \`win32\`
              ? str.replace(/^.*zipfile:\\//, \`\`)
              : str.replace(/^.*zipfile:/, \`\`);
          } break;

          case \`vscode\`:
          default: {
            return process.platform === \`win32\`
              ? str.replace(/^\\^?(zip:|\\/zip)\\/+/, \`\`)
              : str.replace(/^\\^?(zip:|\\/zip)\\/+/, \`/\`);
          } break;
        }
      }

      // Force enable 'allowLocalPluginLoads'
      // TypeScript tries to resolve plugins using a path relative to itself
      // which doesn't work when using the global cache
      // https://github.com/microsoft/TypeScript/blob/1b57a0395e0bff191581c9606aab92832001de62/src/server/project.ts#L2238
      // VSCode doesn't want to enable 'allowLocalPluginLoads' due to security concerns but
      // TypeScript already does local loads and if this code is running the user trusts the workspace
      // https://github.com/microsoft/vscode/issues/45856
      const ConfiguredProject = tsserver.server.ConfiguredProject;
      const {enablePluginsWithOptions: originalEnablePluginsWithOptions} = ConfiguredProject.prototype;
      ConfiguredProject.prototype.enablePluginsWithOptions = function() {
        this.projectService.allowLocalPluginLoads = true;
        return originalEnablePluginsWithOptions.apply(this, arguments);
      };

      // And here is the point where we hijack the VSCode <-> TS communications
      // by adding ourselves in the middle. We locate everything that looks
      // like an absolute path of ours and normalize it.

      const Session = tsserver.server.Session;
      const {onMessage: originalOnMessage, send: originalSend} = Session.prototype;
      let hostInfo = \`unknown\`;

      Object.assign(Session.prototype, {
        onMessage(/** @type {string} */ message) {
          const parsedMessage = JSON.parse(message)

          if (
            parsedMessage != null &&
            typeof parsedMessage === \`object\` &&
            parsedMessage.arguments &&
            typeof parsedMessage.arguments.hostInfo === \`string\`
          ) {
            hostInfo = parsedMessage.arguments.hostInfo;
            if (hostInfo === \`vscode\` && process.env.VSCODE_IPC_HOOK && process.env.VSCODE_IPC_HOOK.match(/Code\\/1\\.([1-5][0-9]|60)\\./)) {
              hostInfo += \` <1.61\`;
            }
          }

          return originalOnMessage.call(this, JSON.stringify(parsedMessage, (key, value) => {
            return typeof value === \`string\` ? fromEditorPath(value) : value;
          }));
        },

        send(/** @type {any} */ msg) {
          return originalSend.call(this, JSON.parse(JSON.stringify(msg, (key, value) => {
            return typeof value === \`string\` ? toEditorPath(value) : value;
          })));
        }
      });

      return tsserver;
    };
  `;
    const wrapper = new generateSdk_1.Wrapper(`typescript`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/tsc`);
    await wrapper.writeBinary(`bin/tsserver`);
    await wrapper.writeFile(`lib/tsc.js`);
    await wrapper.writeFile(`lib/tsserver.js`, { wrapModule: tsServerMonkeyPatch });
    await wrapper.writeFile(`lib/typescript.js`);
    await wrapper.writeFile(`lib/tsserverlibrary.js`, { wrapModule: tsServerMonkeyPatch });
    return wrapper;
};
exports.generateTypescriptBaseWrapper = generateTypescriptBaseWrapper;
const generateStylelintBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`stylelint`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/stylelint.js`);
    await wrapper.writeFile(`lib/index.js`);
    return wrapper;
};
exports.generateStylelintBaseWrapper = generateStylelintBaseWrapper;
const generateSvelteLanguageServerBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`svelte-language-server`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`bin/server.js`);
    return wrapper;
};
exports.generateSvelteLanguageServerBaseWrapper = generateSvelteLanguageServerBaseWrapper;
const generateFlowBinBaseWrapper = async (pnpApi, target) => {
    const wrapper = new generateSdk_1.Wrapper(`flow-bin`, { pnpApi, target });
    await wrapper.writeManifest();
    await wrapper.writeBinary(`cli.js`);
    return wrapper;
};
exports.generateFlowBinBaseWrapper = generateFlowBinBaseWrapper;
exports.BASE_SDKS = [
    [`eslint`, exports.generateEslintBaseWrapper],
    [`prettier`, exports.generatePrettierBaseWrapper],
    [`typescript-language-server`, exports.generateTypescriptLanguageServerBaseWrapper],
    [`typescript`, exports.generateTypescriptBaseWrapper],
    [`stylelint`, exports.generateStylelintBaseWrapper],
    [`svelte-language-server`, exports.generateSvelteLanguageServerBaseWrapper],
    [`flow-bin`, exports.generateFlowBinBaseWrapper],
];
